/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Groovy project to get you started.
 * For more details take a look at the Groovy Quickstart chapter in the Gradle
 * User Manual available at https://docs.gradle.org/5.4.1/userguide/tutorial_groovy_projects.html
 */

// tag::plugins[]
plugins {
    // Apply the groovy plugin to add support for Groovy
    id 'groovy'
    id "com.github.ben-manes.versions" version "0.21.0" // <1>
}
// end::plugins[]

repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// tag::dependencies[]
dependencies {
    // Use the latest Groovy version for building this library
    implementation 'org.codehaus.groovy:groovy-all:2.5.6' // <1>

    // Use the awesome Spock testing and specification framework
    testImplementation 'org.spockframework:spock-core:1.2-groovy-2.5' // <2>
}
// end::dependencies[]

wrapper {
    distributionType = Wrapper.DistributionType.ALL
}

// tag::dependencyUpdates[]
dependencyUpdates {
    boolean failOnUpdate = true // <1>
    List<String> ignoredUpdates = [ // <2>
            /org.codehaus.groovy:groovy.*/, // <3>
            /org.gradle:gradle/ // <4>
    ]
    onlyIf {
        project.version && (project.version as String).endsWith('-SNAPSHOT') // <5>
    }
    outputFormatter = { com.github.benmanes.gradle.versions.reporter.result.Result result -> // <6>
        Closure<Boolean> shouldIgnore = { String groupAndArtifact ->
            ignoredUpdates.any { groupAndArtifact ==~ it }
        }
        boolean hasUpdates = false
        result.outdated.dependencies.each { com.github.benmanes.gradle.versions.reporter.result.DependencyOutdated outdated -> // <7>
            if (!shouldIgnore("${outdated.group}:${outdated.name}")) {
                project.logger.warn(
                        "There is outdated dependency:" +
                                " ${outdated.group}:${outdated.name}:${outdated.version}" +
                                " -> ${outdated.available.release ?: outdated.available.milestone}")
                hasUpdates = true
            }
        }
        if (result.gradle.current.isUpdateAvailable && result.gradle.current > result.gradle.running) { // <8>
            if (!shouldIgnore("org.gradle:gradle")) {
                project.logger.warn(
                        "Gradle is outdated:" +
                                " ${result.gradle.running.version}" +
                                " -> ${result.gradle.current.version}")
                hasUpdates = true
            }
        }
        result.unresolved.dependencies.each { com.github.benmanes.gradle.versions.reporter.result.DependencyUnresolved unresolved -> // <9>
            project.logger.warn(
                    "Could not determine latest version for" +
                            " ${unresolved.group}:${unresolved.name}:${unresolved.version}" +
                            " because ${unresolved.reason}")
        }
        if (hasUpdates && failOnUpdate) { // <10>
            throw new GradleException("Dependencies have to be updated!")
        }
    }
    resolutionStrategy = { ResolutionStrategy strategy -> // <11>
        strategy.componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                if (selection.candidate.version =~ /redhat/ || ['alpha', 'beta', 'rc', 'cr', 'm', 'preview'].
                        any { qualifier -> selection.candidate.version =~ /(?i)\b${qualifier}\d*\b/ }) {
                    selection.reject('Release candidate')
                }
            }
        }
    }
}
check.dependsOn dependencyUpdates // <12>
// end::dependencyUpdates[]
